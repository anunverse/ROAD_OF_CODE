//找出整数的二进制中所有是1的位，所花费的时间与1的个数同级
/*
    原理： 10 = （1010）B 取出最后的1及后面的值，即 10
           1010 取反：0101 使得最后一位1变为0，且之后的元素都为1
           再 + 1： 0110
           1010 & 0110 = 10 
           上述过程可看成是：n & -n 
*/
const MAX_N = 1 << 20;
int H[MAX_N + 1];

for(int i = 0; i <= 20; i++) H[1<<i] = i;
while(cin >> n)
{
    while(n > 0)
    {
        cout << H[n & -n] << ' ';
        n -= n & -n;
    }
    cout << endl;
}

// 2 ^ k mod 37 互不相等，且恰好取遍整数 1 ~ 36
